{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GitHub API Package","text":""},{"location":"#overview","title":"Overview","text":"<p>This project is a supporting package for tools which need to access GitHub's APIs. The package includes a function to authenticate with the API using a GitHub App, a class to use GitHub's RESTful API and a class to perform set queries against GitHub's GraphQL API.</p> <p>This package is primarily used by:</p> <ul> <li>GitHub Repository Archive Tool</li> <li>GitHub CoPilot Usage Dashboard</li> <li>GitHub Policy/Audit Dashboard</li> </ul> <p>For more information about the package's functionality, see the following pages:</p> Name Type Description Link <code>get_token_as_installation()</code> Function A function which gets a GitHub Access Token for a given GitHub App. This allows authenticated API requests to be made. <code>github_interface()</code> Class A class used to interact with GitHub's RESTful API. <code>github_graphql_interface()</code> Class A class used to interact with GitHub's GraphQL API."},{"location":"#techstack-overview","title":"Techstack Overview","text":"<p>This project is written in Python due to its requirement to be used in other Python projects and doesn't use any specific frameworks. The package uses requests to make API calls and JWT to get a GitHub Authentication token.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To setup and use the project, please refer to the README.</p>"},{"location":"documentation/","title":"Documentation","text":"<p>This site uses MkDocs to build its documentation and GitHub Pages for hosting.</p>"},{"location":"documentation/#format","title":"Format","text":"<p>Documentation within this project follows the following pattern:</p> <ul> <li>A <code>README.md</code> for each component</li> <li>A <code>/docs</code> folder for the project</li> </ul> <p>Each <code>README.md</code> should contain:</p> <ul> <li>A description of what the component is/does</li> <li>A list of any prerequisites</li> <li>Setup instructions</li> <li>Execution instructions</li> <li>Deployment instructions</li> </ul> <p>The <code>/docs</code> folder should contain:</p> <ul> <li>A description of what the project is</li> <li>An overview of how the everything fits together in the project</li> <li>An explanation of the tech stack</li> <li>Details of the underlying dataset</li> </ul> <p>A majority of the information should reside within the <code>/docs</code> directory over the <code>README</code>. The <code>README</code>s in this project should be kept for concise instructions on how to use each component. Any detailed explanation should be kept within <code>/docs</code>.</p>"},{"location":"documentation/#getting-mkdocs-setup","title":"Getting MkDocs Setup","text":"<p>In order to build an MkDocs deployment or serve the documentation locally, we need to install MkDocs and its dependencies.</p> <ol> <li> <p>Navigate into the project's root directory.</p> </li> <li> <p>Install MkDocs and its dependencies.</p> <pre><code>pip install -r mkdocs_requirements.txt\n</code></pre> </li> <li> <p>You can now use MkDocs. To see a list of commands run the following:</p> <pre><code>mkdocs --help\n</code></pre> </li> </ol> <p>Please Note: Python's package manager, PIP, is required to install MkDocs. Please make sure you have Python installed beforehand.</p>"},{"location":"documentation/#updating-mkdocs-deployment","title":"Updating MkDocs Deployment","text":"<p>If changes are made within <code>/docs</code>, the GitHub Pages deployment will need to be updated. Assuming you have already installed MkDocs and Material for MkDocs, do the following:</p> <ol> <li> <p>Navigate to the projects root directory.</p> </li> <li> <p>Delete the existing <code>/mkdocs_deployment</code> directory.</p> </li> <li> <p>Build the MkDocs deployment.</p> <pre><code>mkdocs build\n</code></pre> </li> <li> <p>Rename the <code>/site</code> directory to <code>/mkdocs_deployment</code>. This allows git to track the build so GitHub Pages can redeploy it.</p> </li> <li> <p>Commit and Push changes.</p> </li> </ol> <p>Once completed, a GitHub Action will redeploy the new build to GitHub Pages.</p>"},{"location":"testing/","title":"Testing","text":"<p>This repository makes use of the <code>pytest</code> framework for testing (see documentation). This allows modules within the API toolkit to be tested. All tests can be found within <code>/tests</code>.</p>"},{"location":"testing/#test_get_codeowners_from_textpy","title":"<code>test_get_codeowners_from_text.py</code>","text":"<p>The tests within this script involve testing <code>get_codeowners_from_text()</code> against 10 different CODEOWNERS file formats. Since this is a major function within the toolkit, and has lots of dependent functions, all tests must pass to ensure the functionality is correct.</p> <p>The test uses various CODEOWNER file formats, taken from real ONS repositories. For security reasons, all team and username have been removed. The test also includes GitHub's example CODEOWNERS file which showcases all the CODEOWNERS functionality (see below).</p> <p>Example taken from GitHub Docs (link).</p> <pre><code># This is a comment.\n# Each line is a file pattern followed by one or more owners.\n\n# These owners will be the default owners for everything in\n# the repo. Unless a later match takes precedence,\n# @global-owner1 and @global-owner2 will be requested for\n# review when someone opens a pull request.\n*       @global-owner1 @global-owner2\n\n# Order is important; the last matching pattern takes the most\n# precedence. When someone opens a pull request that only\n# modifies JS files, only @js-owner and not the global\n# owner(s) will be requested for a review.\n*.js    @js-owner #This is an inline comment.\n\n# You can also use email addresses if you prefer. They'll be\n# used to look up users just like we do for commit author\n# emails.\n*.go docs@example.com\n\n# Teams can be specified as code owners as well. Teams should\n# be identified in the format @org/team-name. Teams must have\n# explicit write access to the repository. In this example,\n# the octocats team in the octo-org organization owns all .txt files.\n*.txt @octo-org/octocats\n\n# In this example, @doctocat owns any files in the build/logs\n# directory at the root of the repository and any of its\n# subdirectories.\n/build/logs/ @doctocat\n\n# The `docs/*` pattern will match files like\n# `docs/getting-started.md` but not further nested files like\n# `docs/build-app/troubleshooting.md`.\ndocs/*  docs@example.com\n\n# In this example, @octocat owns any file in an apps directory\n# anywhere in your repository.\napps/ @octocat\n\n# In this example, @doctocat owns any file in the `/docs`\n# directory in the root of your repository and any of its\n# subdirectories.\n/docs/ @doctocat\n\n# In this example, any change inside the `/scripts` directory\n# will require approval from @doctocat or @octocat.\n/scripts/ @doctocat @octocat\n\n# In this example, @octocat owns any file in a `/logs` directory such as\n# `/build/logs`, `/scripts/logs`, and `/deeply/nested/logs`. Any changes\n# in a `/logs` directory will require approval from @octocat.\n**/logs @octocat\n\n# In this example, @octocat owns any file in the `/apps`\n# directory in the root of your repository except for the `/apps/github`\n# subdirectory, as its owners are left empty.\n/apps/ @octocat\n/apps/github\n\n# In this example, @octocat owns any file in the `/apps`\n# directory in the root of your repository except for the `/apps/github`\n# subdirectory, as this subdirectory has its own owner @doctocat\n/apps/ @octocat\n/apps/github @doctocat\n</code></pre>"},{"location":"example_use_cases/getting_a_repository_owner/","title":"Getting a Repository Owner","text":""},{"location":"example_use_cases/getting_a_repository_owner/#overview","title":"Overview","text":"<p>A major use case for the GraphQL section of the toolkit, is to get a point of contact for a given repository. This can be done using the <code>github_graphql_interface()</code> class.</p>"},{"location":"example_use_cases/getting_a_repository_owner/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>The GitHub organisation must have verified domain emails. Please see this GitHub Doc.</p> </li> <li> <p>The repository must contain a CODEOWNERS file at either the root of the repository, within a <code>.github</code> folder at the root of the repository or within a <code>/docs</code> folder at the root of the repository.</p> </li> <li> <p>The CODEOWNERS file can contain a mixture of GitHub Teams and Usernames. Emails within a CODEOWNERS file are ignored.</p> </li> <li> <p>The GitHub Team within the CODEOWNERS file must have a member with the maintainer role. This person is identified as a repository owner from the team.</p> </li> </ol>"},{"location":"example_use_cases/getting_a_repository_owner/#python-example","title":"Python Example","text":"<p>The following code snippet does the following:</p> <ol> <li> <p>Get all variables from the environment.</p> </li> <li> <p>Create a GitHub Access Token to make API requests.</p> </li> <li> <p>Create an instance of the GraphQL interface.</p> </li> <li> <p>Run <code>get_repository_email_list()</code> to get a list of CODEOWNER emails for that repository.</p> </li> </ol> <pre><code>import github_api_toolkit as gat\nfrom os import getenv\n\ngithub_org = getenv(\"GITHUB_ORG\")\npem_contents = getenv(\"SECRET\")\ngithub_app_id = getenv(\"APP_ID\")\ngithub_repo = getenv(\"GITHUB_REPO\")\n\ntoken = gat.get_token_as_installation(github_org, pem_contents, github_app_id)\n\napi = gat.github_graphql_interface(token[0])\n\nemails = api.get_repository_email_list(github_org, github_repo)\n\nprint(emails)\n</code></pre>"},{"location":"reference/get_token_as_installation/","title":"<code>get_token_as_installation()</code>","text":"<p>Get an access token for a GitHub App installed in an organization.</p> <p>Generates an encoded JSON Web Token (JWT) using the GitHub app client ID and the private key (pem_contents). The JWT is used to get the installation ID of the GitHub App in the organization. The installation ID is then used to get an access token for the GitHub App. The access token is returned along with the expiration time.</p> <p>Parameters:</p> Name Type Description Default <code>org</code> <code>str</code> <p>The GitHub organization name which the GitHub App is installed in.</p> required <code>pem_contents</code> <code>str</code> <p>The contents of the private key file for the GitHub App.</p> required <code>app_client_id</code> <code>str</code> <p>The GitHub App Client ID.</p> required <p>Returns:</p> Type Description <code>tuple | Exception</code> <p>A tuple containing the access token and the expiration time.</p> <code>tuple | Exception</code> <p>If an error occurs, an Exception object is returned to be handled by the importing program.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get_token_as_installation(org: str, pem_contents: str, app_client_id: str) -&gt; tuple | Exception:\n    \"\"\"Get an access token for a GitHub App installed in an organization.\n\n    Generates an encoded JSON Web Token (JWT) using the GitHub app client ID and the private key (pem_contents).\n    The JWT is used to get the installation ID of the GitHub App in the organization.\n    The installation ID is then used to get an access token for the GitHub App.\n    The access token is returned along with the expiration time.\n\n    Args:\n        org (str): The GitHub organization name which the GitHub App is installed in.\n        pem_contents (str): The contents of the private key file for the GitHub App.\n        app_client_id (str): The GitHub App Client ID.\n\n    Returns:\n        A tuple containing the access token and the expiration time.\n        If an error occurs, an Exception object is returned to be handled by the importing program.\n    \"\"\"\n\n    # Generate JSON Web Token\n    issue_time = time.time()\n    expiration_time = issue_time + 600\n\n    try:\n        signing_key = jwt.jwk_from_pem(pem_contents.encode())\n    except jwt.exceptions.UnsupportedKeyTypeError as err:\n        return(err)\n\n    payload = {\n        # Issued at time\n        \"iat\": int(issue_time),\n        # Expiration time\n        \"exp\": int(expiration_time),\n        # Github App CLient ID\n        \"iss\": app_client_id\n    }\n\n    jwt_instance = jwt.JWT()\n    encoded_jwt = jwt_instance.encode(payload, signing_key, alg=\"RS256\")\n\n    # Get Installation ID\n    header = {\"Authorization\": f\"Bearer {encoded_jwt}\"}\n\n    try:\n        response = requests.get(url=f\"https://api.github.com/orgs/{org}/installation\", headers=header)\n\n        response.raise_for_status()\n\n        installation_json = response.json()\n        installation_id = installation_json[\"id\"]\n\n        # Get Access Token\n        response = requests.post(url=f\"https://api.github.com/app/installations/{installation_id}/access_tokens\", headers=header)\n        access_token = response.json()\n        return (access_token[\"token\"], access_token[\"expires_at\"])\n\n    except requests.exceptions.HTTPError as errh:\n        return(errh)\n    except requests.exceptions.ConnectionError as errc:\n        return(errc)\n    except requests.exceptions.Timeout as errt:\n        return(errt)\n    except requests.exceptions.RequestException as err:\n        return(err)\n</code></pre>"},{"location":"reference/github_graphql_interface/","title":"<code>github_graphql_interface()</code>","text":"<p>A class used to interact with the GitHub GraphQL API. Has a set range of functions.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>class github_graphql_interface():\n    \"\"\"A class used to interact with the GitHub GraphQL API. Has a set range of functions.\n    \"\"\"\n\n    def __init__(self, token: str) -&gt; None:\n        self.headers = { \"Authorization\": \"token \" + token }\n        self.api_url = \"https://api.github.com/graphql\"\n\n    def get_error_message(self, response: requests.Response) -&gt; tuple:\n        \"\"\"Gets the error message and status code from a response.\n\n        Args:\n            response (requests.Response): The response from the API endpoint.\n\n        Returns:\n            tuple: A tuple containing the error message and status code.\n        \"\"\"\n\n        response_json = response.json()\n        return response_json.get(\"message\", \"No Error Message\"), response_json.get(\"status\", \"Unknown status\")\n\n    def make_ql_request(self, query: str, params: dict) -&gt; requests.Response:\n        \"\"\"Makes a request to the GitHub GraphQL API.\n\n        Args:\n            query (str): The GraphQL query to be executed.\n            params (dict): A dictionary containing the variables for the query.\n\n        Returns:\n            requests.Response: The response from the API endpoint.\n        \"\"\"\n\n        self.json = {\n            'query': query,\n            'variables': params\n        }\n\n        return requests.post(url=self.api_url, json=self.json, headers=self.headers)\n\n    def get_domain_email_by_user(self, username: str, org: str) -&gt; list | tuple:\n        \"\"\"Gets a GitHub user's verified domain email for a specific organization.\n\n        Args:\n            username (str): The GitHub username of the user.\n            org (str): The GitHub organization name.\n\n        Returns:\n            list | tuple: A list of verified domain emails for the user in the organization or a tuple containing an error message and status code.\n        \"\"\"\n\n        self.query = '''\n            query ($username: String!, $org: String!) {\n                user (login: $username) {\n                    login\n                    organizationVerifiedDomainEmails(login: $org)\n                }\n            }\n        '''\n\n        self.params = {\n            'username': username,\n            'org': org\n        }\n\n        response = self.make_ql_request(self.query, self.params)\n\n        if response.status_code == 200:\n            return response.json()[\"data\"][\"user\"][\"organizationVerifiedDomainEmails\"]\n        else:\n            return self.get_error_message(response)\n\n    def get_file_contents_from_repo(self, owner: str, repo: str, path: str, branch: str = \"main\") -&gt; str:\n        \"\"\"Gets the contents of a file from a GitHub Repository.\n\n        Args:\n            owner (str): The owner of the repository.\n            repo (str): The repository name.\n            path (str): The path to the file.\n            branch (str, optional): The branch the file is on. Defaults to \"main\".\n\n        Returns:\n            str: The contents of the file.\n        \"\"\"\n\n        self.query = f'''\n            query ($owner: String!, $repo: String!) {{\n                repository(owner: $owner, name: $repo) {{\n                    file: object(expression: \"{branch}:{path}\") {{\n                        ... on Blob {{\n                            text\n                        }}\n                    }}\n                }}\n            }}\n        '''\n\n        self.params = {\n            'owner': owner,\n            'repo': repo\n        }\n\n        response = self.make_ql_request(self.query, self.params)\n\n        if response.status_code == 200:\n            try:\n                contents = response.json()[\"data\"][\"repository\"][\"file\"][\"text\"]\n                return contents\n            except TypeError:\n                # If there is a type error, [\"data\"][\"repository\"][\"file\"] is None\n                # Therefore, the file was not found\n                return \"File not found.\"\n        else:\n            return self.get_error_message(response)\n\n    def check_directory_for_file(self, owner: str, repo: str, path: str, branch: str) -&gt; str | None:\n        \"\"\"Checks if a file exists in a repository.\n\n        Args:\n            owner (str): The owner of the repository.\n            repo (str): The repository name.\n            path (str): The path to the file.\n            branch (str): The branch the file is on.\n\n        Returns:\n            str | None: The path to the file is found or None if the file is not found.\n        \"\"\"\n\n        response = self.get_file_contents_from_repo(owner, repo, path, branch)\n\n        if response != \"File not found.\":\n            return path\n\n        return\n\n    def locate_codeowners_file(self, owner: str, repo: str, branch: str = \"main\") -&gt; str | None:\n        \"\"\"Locates the CODEOWNERS file in a repository.\n\n        The CODEOWNERS file can be located in the root of the repository, in the .github/ directory, or in the docs/ directory.\n\n        Args:\n            owner (str): The owner of the repository.\n            repo (str): The repository name.\n            branch (str, optional): The branch the file is on. Defaults to \"main\".\n\n\n        Returns:\n            str | None: The path to the CODEOWNERS file or None if the file is not found.\n        \"\"\"\n\n        # Check root directory\n        response_codeowners = self.check_directory_for_file(owner, repo, \"CODEOWNERS\", branch)\n\n        # Check .github directory\n        response_github = self.check_directory_for_file(owner, repo, \".github/CODEOWNERS\", branch)\n\n        # Check docs directory\n        response_docs = self.check_directory_for_file(owner, repo, \"docs/CODEOWNERS\", branch)\n\n        if response_codeowners:\n            return response_codeowners\n        elif response_github:\n            return response_github\n        elif response_docs:\n            return response_docs\n\n        return\n\n    def get_codeowners_from_text(self, codeowners_content: str) -&gt; list:\n        \"\"\"Gets a list of users and teams from a CODEOWNERS file.\n\n        Args:\n            codeowners_content (str): The contents of a CODEOWNERS file.\n\n        Returns:\n            list: A list of users and teams from the CODEOWNERS file.\n        \"\"\"\n\n        # Process:\n        # 1. Split the CODEOWNERS file into lines.\n        # 2. Remove empty lines and comments.\n        # 3. Find the index of all instances of @ in the lines.\n        # 4. Find the index of when the word after the @ ends (i.e. space, end of line).\n        # 5. Get the substring from the @ to the end of the word and add to a list.\n        # 6. Remove any emails from the list.\n        # 7. Remove duplicates from the list.\n        # 8. Return the list.\n\n        codeowner_lines = codeowners_content.split(\"\\n\")\n\n        lines_removed = 0\n\n        for i in range(len(codeowner_lines)):\n            # If line is empty, remove it\n\n            if codeowner_lines[i-lines_removed] == \"\":\n                codeowner_lines.pop(i-lines_removed)\n                lines_removed += 1\n\n            # If whole line is a comment, remove it\n            elif codeowner_lines[i-lines_removed][0] == \"#\":\n                codeowner_lines.pop(i-lines_removed)\n                lines_removed += 1\n\n            # If line has a comment, remove the comment\n            elif \"#\" in codeowner_lines[i-lines_removed]:\n                comment_index = codeowner_lines[i-lines_removed].find(\"#\")\n                codeowner_lines[i-lines_removed] = codeowner_lines[i-lines_removed][:comment_index]\n\n        codeowner_handles = []\n\n        for line in codeowner_lines:\n            for i in range(len(line)):\n                if line[i] == \"@\":\n                    next_space = line.find(\" \", i)\n                    if next_space == -1:\n                        codeowner_handles.append(line[i:])\n                    else:\n                        codeowner_handles.append(line[i:next_space])\n\n        # The function will grab the end of the emails (i.e. @example.com)\n        # These emails need to be removed from the list of codeowner_handles\n\n        email_pattern = r'(@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})'\n\n        lines_removed = 0\n\n        for i in range(len(codeowner_handles)):\n            if len(re.findall(email_pattern, codeowner_handles[i-lines_removed])) &gt; 0:\n                codeowner_handles.pop(i-lines_removed)\n                lines_removed += 1\n\n        # Remove duplicates\n        codeowner_handles = list(dict.fromkeys(codeowner_handles))\n\n        return codeowner_handles\n\n    def identify_teams_and_users(self, codeowners_list: list) -&gt; list:\n        \"\"\"Iterates through a list of users and teams and identifies the type of each.\n\n        Args:\n            codeowners_list (list): A list of users and teams from a CODEOWNERS file to sort.\n\n        Returns:\n            list: A list of dictionaries containing the type and name of each user and team.\n        \"\"\"\n\n        team_and_user_list = []\n\n        for i in range(len(codeowners_list)):\n            if \"/\" in codeowners_list[i]:\n                # This is a team\n                # Need to remove org from team name\n\n                codeowners_list[i] = codeowners_list[i].split(\"/\")[-1]\n\n                team_and_user_list.append({\n                    \"type\": \"team\",\n                    \"name\": codeowners_list[i]\n                })\n            else:\n                # This is a user\n\n                codeowners_list[i] = codeowners_list[i].replace(\"@\", \"\")\n\n                team_and_user_list.append({\n                    \"type\": \"user\",\n                    \"name\": codeowners_list[i]\n                })\n\n        return team_and_user_list\n\n    def get_team_maintainers(self, org: str, team_name: str) -&gt; list | tuple:\n        \"\"\"Gets the maintainers of a GitHub team.\n\n        Args:\n            org (str): the GitHub organization name.\n            team_name (str): the GitHub team name.\n\n        Returns:\n            list | tuple: A list of maintainers in the team or a tuple containing an error message and status code.\n        \"\"\"\n\n        self.query = '''\n            query ($org: String!, $team_name: String!) {\n                organization(login: $org) {\n                    team(slug: $team_name) {\n                        members(role: MAINTAINER) {\n                            nodes {\n                                login\n                            }\n                        }\n                    }\n                }\n            }\n        '''\n\n        self.params = {\n            'org': org,\n            'team_name': team_name\n        }\n\n        response = self.make_ql_request(self.query, self.params)\n\n        if response.status_code == 200:\n            return response.json()[\"data\"][\"organization\"][\"team\"][\"members\"][\"nodes\"]\n        else:\n            return self.get_error_message(response)\n\n    def get_codeowner_users(self, org: str, codeowners: list) -&gt; list:\n        \"\"\"Gets a list of users from a list of users and teams. Will get the maintainers of any teams and add them as a user.\n\n        Args:\n            org (str): The GitHub organization name.\n            codeowners (list): A list of users and teams from a CODEOWNERS file.\n\n        Returns:\n            list: A list of users from the CODEOWNERS file.\n        \"\"\"\n\n        users = []\n\n        for codeowner in codeowners:\n            if codeowner[\"type\"] == \"team\":\n                team_maintainers = self.get_team_maintainers(org, codeowner[\"name\"])\n\n                for maintainer in team_maintainers:\n                    users.append(maintainer[\"login\"])\n\n            elif codeowner[\"type\"] == \"user\":\n                users.append(codeowner[\"name\"])\n\n        # Remove duplicates\n        users = list(dict.fromkeys(users))\n\n        return users\n\n    def get_codeowner_emails(self, codeowners: list, org: str) -&gt; list:\n        \"\"\"Gets a list of verified domain emails for a list of users.\n\n        Args:\n            codeowners (list): A list of users from a CODEOWNERS file.\n            org (str): The GitHub organization to get the email for.\n\n        Returns:\n            list: A list of verified domain emails for the users.\n        \"\"\"\n\n        emails = []\n\n        for codeowner in codeowners:\n            user_emails = self.get_domain_email_by_user(codeowner, org)\n\n            for email in user_emails:\n                emails.append(email)\n\n        return emails\n\n    def get_repository_email_list(self, org: str, repo: str, branch: str = \"main\") -&gt; list:\n        \"\"\"Gets a list of verified domain emails for the codeowners of a repository.\n\n        Args:\n            org (str): The GitHub organization name.\n            repo (str): The GitHub repository name.\n            branch (str, optional): The branch to check. Defaults to \"main\".\n\n        Returns:\n            list: A list of verified domain emails for the codeowners of the repository.\n        \"\"\"\n\n        codeowners_path = self.locate_codeowners_file(org, repo, branch)\n\n        contents = self.get_file_contents_from_repo(org, repo, codeowners_path)\n\n        codeowners = self.get_codeowners_from_text(contents)\n\n        codeowners = self.identify_teams_and_users(codeowners)\n\n        codeowners = self.get_codeowner_users(org, codeowners)\n\n        emails = self.get_codeowner_emails(codeowners, org)\n\n        return emails\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.check_directory_for_file","title":"<code>check_directory_for_file(owner, repo, path, branch)</code>","text":"<p>Checks if a file exists in a repository.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The owner of the repository.</p> required <code>repo</code> <code>str</code> <p>The repository name.</p> required <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>branch</code> <code>str</code> <p>The branch the file is on.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The path to the file is found or None if the file is not found.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def check_directory_for_file(self, owner: str, repo: str, path: str, branch: str) -&gt; str | None:\n    \"\"\"Checks if a file exists in a repository.\n\n    Args:\n        owner (str): The owner of the repository.\n        repo (str): The repository name.\n        path (str): The path to the file.\n        branch (str): The branch the file is on.\n\n    Returns:\n        str | None: The path to the file is found or None if the file is not found.\n    \"\"\"\n\n    response = self.get_file_contents_from_repo(owner, repo, path, branch)\n\n    if response != \"File not found.\":\n        return path\n\n    return\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.get_codeowner_emails","title":"<code>get_codeowner_emails(codeowners, org)</code>","text":"<p>Gets a list of verified domain emails for a list of users.</p> <p>Parameters:</p> Name Type Description Default <code>codeowners</code> <code>list</code> <p>A list of users from a CODEOWNERS file.</p> required <code>org</code> <code>str</code> <p>The GitHub organization to get the email for.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of verified domain emails for the users.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get_codeowner_emails(self, codeowners: list, org: str) -&gt; list:\n    \"\"\"Gets a list of verified domain emails for a list of users.\n\n    Args:\n        codeowners (list): A list of users from a CODEOWNERS file.\n        org (str): The GitHub organization to get the email for.\n\n    Returns:\n        list: A list of verified domain emails for the users.\n    \"\"\"\n\n    emails = []\n\n    for codeowner in codeowners:\n        user_emails = self.get_domain_email_by_user(codeowner, org)\n\n        for email in user_emails:\n            emails.append(email)\n\n    return emails\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.get_codeowner_users","title":"<code>get_codeowner_users(org, codeowners)</code>","text":"<p>Gets a list of users from a list of users and teams. Will get the maintainers of any teams and add them as a user.</p> <p>Parameters:</p> Name Type Description Default <code>org</code> <code>str</code> <p>The GitHub organization name.</p> required <code>codeowners</code> <code>list</code> <p>A list of users and teams from a CODEOWNERS file.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of users from the CODEOWNERS file.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get_codeowner_users(self, org: str, codeowners: list) -&gt; list:\n    \"\"\"Gets a list of users from a list of users and teams. Will get the maintainers of any teams and add them as a user.\n\n    Args:\n        org (str): The GitHub organization name.\n        codeowners (list): A list of users and teams from a CODEOWNERS file.\n\n    Returns:\n        list: A list of users from the CODEOWNERS file.\n    \"\"\"\n\n    users = []\n\n    for codeowner in codeowners:\n        if codeowner[\"type\"] == \"team\":\n            team_maintainers = self.get_team_maintainers(org, codeowner[\"name\"])\n\n            for maintainer in team_maintainers:\n                users.append(maintainer[\"login\"])\n\n        elif codeowner[\"type\"] == \"user\":\n            users.append(codeowner[\"name\"])\n\n    # Remove duplicates\n    users = list(dict.fromkeys(users))\n\n    return users\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.get_codeowners_from_text","title":"<code>get_codeowners_from_text(codeowners_content)</code>","text":"<p>Gets a list of users and teams from a CODEOWNERS file.</p> <p>Parameters:</p> Name Type Description Default <code>codeowners_content</code> <code>str</code> <p>The contents of a CODEOWNERS file.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of users and teams from the CODEOWNERS file.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get_codeowners_from_text(self, codeowners_content: str) -&gt; list:\n    \"\"\"Gets a list of users and teams from a CODEOWNERS file.\n\n    Args:\n        codeowners_content (str): The contents of a CODEOWNERS file.\n\n    Returns:\n        list: A list of users and teams from the CODEOWNERS file.\n    \"\"\"\n\n    # Process:\n    # 1. Split the CODEOWNERS file into lines.\n    # 2. Remove empty lines and comments.\n    # 3. Find the index of all instances of @ in the lines.\n    # 4. Find the index of when the word after the @ ends (i.e. space, end of line).\n    # 5. Get the substring from the @ to the end of the word and add to a list.\n    # 6. Remove any emails from the list.\n    # 7. Remove duplicates from the list.\n    # 8. Return the list.\n\n    codeowner_lines = codeowners_content.split(\"\\n\")\n\n    lines_removed = 0\n\n    for i in range(len(codeowner_lines)):\n        # If line is empty, remove it\n\n        if codeowner_lines[i-lines_removed] == \"\":\n            codeowner_lines.pop(i-lines_removed)\n            lines_removed += 1\n\n        # If whole line is a comment, remove it\n        elif codeowner_lines[i-lines_removed][0] == \"#\":\n            codeowner_lines.pop(i-lines_removed)\n            lines_removed += 1\n\n        # If line has a comment, remove the comment\n        elif \"#\" in codeowner_lines[i-lines_removed]:\n            comment_index = codeowner_lines[i-lines_removed].find(\"#\")\n            codeowner_lines[i-lines_removed] = codeowner_lines[i-lines_removed][:comment_index]\n\n    codeowner_handles = []\n\n    for line in codeowner_lines:\n        for i in range(len(line)):\n            if line[i] == \"@\":\n                next_space = line.find(\" \", i)\n                if next_space == -1:\n                    codeowner_handles.append(line[i:])\n                else:\n                    codeowner_handles.append(line[i:next_space])\n\n    # The function will grab the end of the emails (i.e. @example.com)\n    # These emails need to be removed from the list of codeowner_handles\n\n    email_pattern = r'(@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})'\n\n    lines_removed = 0\n\n    for i in range(len(codeowner_handles)):\n        if len(re.findall(email_pattern, codeowner_handles[i-lines_removed])) &gt; 0:\n            codeowner_handles.pop(i-lines_removed)\n            lines_removed += 1\n\n    # Remove duplicates\n    codeowner_handles = list(dict.fromkeys(codeowner_handles))\n\n    return codeowner_handles\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.get_domain_email_by_user","title":"<code>get_domain_email_by_user(username, org)</code>","text":"<p>Gets a GitHub user's verified domain email for a specific organization.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The GitHub username of the user.</p> required <code>org</code> <code>str</code> <p>The GitHub organization name.</p> required <p>Returns:</p> Type Description <code>list | tuple</code> <p>list | tuple: A list of verified domain emails for the user in the organization or a tuple containing an error message and status code.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get_domain_email_by_user(self, username: str, org: str) -&gt; list | tuple:\n    \"\"\"Gets a GitHub user's verified domain email for a specific organization.\n\n    Args:\n        username (str): The GitHub username of the user.\n        org (str): The GitHub organization name.\n\n    Returns:\n        list | tuple: A list of verified domain emails for the user in the organization or a tuple containing an error message and status code.\n    \"\"\"\n\n    self.query = '''\n        query ($username: String!, $org: String!) {\n            user (login: $username) {\n                login\n                organizationVerifiedDomainEmails(login: $org)\n            }\n        }\n    '''\n\n    self.params = {\n        'username': username,\n        'org': org\n    }\n\n    response = self.make_ql_request(self.query, self.params)\n\n    if response.status_code == 200:\n        return response.json()[\"data\"][\"user\"][\"organizationVerifiedDomainEmails\"]\n    else:\n        return self.get_error_message(response)\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.get_error_message","title":"<code>get_error_message(response)</code>","text":"<p>Gets the error message and status code from a response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The response from the API endpoint.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing the error message and status code.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get_error_message(self, response: requests.Response) -&gt; tuple:\n    \"\"\"Gets the error message and status code from a response.\n\n    Args:\n        response (requests.Response): The response from the API endpoint.\n\n    Returns:\n        tuple: A tuple containing the error message and status code.\n    \"\"\"\n\n    response_json = response.json()\n    return response_json.get(\"message\", \"No Error Message\"), response_json.get(\"status\", \"Unknown status\")\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.get_file_contents_from_repo","title":"<code>get_file_contents_from_repo(owner, repo, path, branch='main')</code>","text":"<p>Gets the contents of a file from a GitHub Repository.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The owner of the repository.</p> required <code>repo</code> <code>str</code> <p>The repository name.</p> required <code>path</code> <code>str</code> <p>The path to the file.</p> required <code>branch</code> <code>str</code> <p>The branch the file is on. Defaults to \"main\".</p> <code>'main'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The contents of the file.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get_file_contents_from_repo(self, owner: str, repo: str, path: str, branch: str = \"main\") -&gt; str:\n    \"\"\"Gets the contents of a file from a GitHub Repository.\n\n    Args:\n        owner (str): The owner of the repository.\n        repo (str): The repository name.\n        path (str): The path to the file.\n        branch (str, optional): The branch the file is on. Defaults to \"main\".\n\n    Returns:\n        str: The contents of the file.\n    \"\"\"\n\n    self.query = f'''\n        query ($owner: String!, $repo: String!) {{\n            repository(owner: $owner, name: $repo) {{\n                file: object(expression: \"{branch}:{path}\") {{\n                    ... on Blob {{\n                        text\n                    }}\n                }}\n            }}\n        }}\n    '''\n\n    self.params = {\n        'owner': owner,\n        'repo': repo\n    }\n\n    response = self.make_ql_request(self.query, self.params)\n\n    if response.status_code == 200:\n        try:\n            contents = response.json()[\"data\"][\"repository\"][\"file\"][\"text\"]\n            return contents\n        except TypeError:\n            # If there is a type error, [\"data\"][\"repository\"][\"file\"] is None\n            # Therefore, the file was not found\n            return \"File not found.\"\n    else:\n        return self.get_error_message(response)\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.get_repository_email_list","title":"<code>get_repository_email_list(org, repo, branch='main')</code>","text":"<p>Gets a list of verified domain emails for the codeowners of a repository.</p> <p>Parameters:</p> Name Type Description Default <code>org</code> <code>str</code> <p>The GitHub organization name.</p> required <code>repo</code> <code>str</code> <p>The GitHub repository name.</p> required <code>branch</code> <code>str</code> <p>The branch to check. Defaults to \"main\".</p> <code>'main'</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of verified domain emails for the codeowners of the repository.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get_repository_email_list(self, org: str, repo: str, branch: str = \"main\") -&gt; list:\n    \"\"\"Gets a list of verified domain emails for the codeowners of a repository.\n\n    Args:\n        org (str): The GitHub organization name.\n        repo (str): The GitHub repository name.\n        branch (str, optional): The branch to check. Defaults to \"main\".\n\n    Returns:\n        list: A list of verified domain emails for the codeowners of the repository.\n    \"\"\"\n\n    codeowners_path = self.locate_codeowners_file(org, repo, branch)\n\n    contents = self.get_file_contents_from_repo(org, repo, codeowners_path)\n\n    codeowners = self.get_codeowners_from_text(contents)\n\n    codeowners = self.identify_teams_and_users(codeowners)\n\n    codeowners = self.get_codeowner_users(org, codeowners)\n\n    emails = self.get_codeowner_emails(codeowners, org)\n\n    return emails\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.get_team_maintainers","title":"<code>get_team_maintainers(org, team_name)</code>","text":"<p>Gets the maintainers of a GitHub team.</p> <p>Parameters:</p> Name Type Description Default <code>org</code> <code>str</code> <p>the GitHub organization name.</p> required <code>team_name</code> <code>str</code> <p>the GitHub team name.</p> required <p>Returns:</p> Type Description <code>list | tuple</code> <p>list | tuple: A list of maintainers in the team or a tuple containing an error message and status code.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get_team_maintainers(self, org: str, team_name: str) -&gt; list | tuple:\n    \"\"\"Gets the maintainers of a GitHub team.\n\n    Args:\n        org (str): the GitHub organization name.\n        team_name (str): the GitHub team name.\n\n    Returns:\n        list | tuple: A list of maintainers in the team or a tuple containing an error message and status code.\n    \"\"\"\n\n    self.query = '''\n        query ($org: String!, $team_name: String!) {\n            organization(login: $org) {\n                team(slug: $team_name) {\n                    members(role: MAINTAINER) {\n                        nodes {\n                            login\n                        }\n                    }\n                }\n            }\n        }\n    '''\n\n    self.params = {\n        'org': org,\n        'team_name': team_name\n    }\n\n    response = self.make_ql_request(self.query, self.params)\n\n    if response.status_code == 200:\n        return response.json()[\"data\"][\"organization\"][\"team\"][\"members\"][\"nodes\"]\n    else:\n        return self.get_error_message(response)\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.identify_teams_and_users","title":"<code>identify_teams_and_users(codeowners_list)</code>","text":"<p>Iterates through a list of users and teams and identifies the type of each.</p> <p>Parameters:</p> Name Type Description Default <code>codeowners_list</code> <code>list</code> <p>A list of users and teams from a CODEOWNERS file to sort.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of dictionaries containing the type and name of each user and team.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def identify_teams_and_users(self, codeowners_list: list) -&gt; list:\n    \"\"\"Iterates through a list of users and teams and identifies the type of each.\n\n    Args:\n        codeowners_list (list): A list of users and teams from a CODEOWNERS file to sort.\n\n    Returns:\n        list: A list of dictionaries containing the type and name of each user and team.\n    \"\"\"\n\n    team_and_user_list = []\n\n    for i in range(len(codeowners_list)):\n        if \"/\" in codeowners_list[i]:\n            # This is a team\n            # Need to remove org from team name\n\n            codeowners_list[i] = codeowners_list[i].split(\"/\")[-1]\n\n            team_and_user_list.append({\n                \"type\": \"team\",\n                \"name\": codeowners_list[i]\n            })\n        else:\n            # This is a user\n\n            codeowners_list[i] = codeowners_list[i].replace(\"@\", \"\")\n\n            team_and_user_list.append({\n                \"type\": \"user\",\n                \"name\": codeowners_list[i]\n            })\n\n    return team_and_user_list\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.locate_codeowners_file","title":"<code>locate_codeowners_file(owner, repo, branch='main')</code>","text":"<p>Locates the CODEOWNERS file in a repository.</p> <p>The CODEOWNERS file can be located in the root of the repository, in the .github/ directory, or in the docs/ directory.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>The owner of the repository.</p> required <code>repo</code> <code>str</code> <p>The repository name.</p> required <code>branch</code> <code>str</code> <p>The branch the file is on. Defaults to \"main\".</p> <code>'main'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The path to the CODEOWNERS file or None if the file is not found.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def locate_codeowners_file(self, owner: str, repo: str, branch: str = \"main\") -&gt; str | None:\n    \"\"\"Locates the CODEOWNERS file in a repository.\n\n    The CODEOWNERS file can be located in the root of the repository, in the .github/ directory, or in the docs/ directory.\n\n    Args:\n        owner (str): The owner of the repository.\n        repo (str): The repository name.\n        branch (str, optional): The branch the file is on. Defaults to \"main\".\n\n\n    Returns:\n        str | None: The path to the CODEOWNERS file or None if the file is not found.\n    \"\"\"\n\n    # Check root directory\n    response_codeowners = self.check_directory_for_file(owner, repo, \"CODEOWNERS\", branch)\n\n    # Check .github directory\n    response_github = self.check_directory_for_file(owner, repo, \".github/CODEOWNERS\", branch)\n\n    # Check docs directory\n    response_docs = self.check_directory_for_file(owner, repo, \"docs/CODEOWNERS\", branch)\n\n    if response_codeowners:\n        return response_codeowners\n    elif response_github:\n        return response_github\n    elif response_docs:\n        return response_docs\n\n    return\n</code></pre>"},{"location":"reference/github_graphql_interface/#github_api_toolkit.github_graphql_interface.make_ql_request","title":"<code>make_ql_request(query, params)</code>","text":"<p>Makes a request to the GitHub GraphQL API.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The GraphQL query to be executed.</p> required <code>params</code> <code>dict</code> <p>A dictionary containing the variables for the query.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>requests.Response: The response from the API endpoint.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def make_ql_request(self, query: str, params: dict) -&gt; requests.Response:\n    \"\"\"Makes a request to the GitHub GraphQL API.\n\n    Args:\n        query (str): The GraphQL query to be executed.\n        params (dict): A dictionary containing the variables for the query.\n\n    Returns:\n        requests.Response: The response from the API endpoint.\n    \"\"\"\n\n    self.json = {\n        'query': query,\n        'variables': params\n    }\n\n    return requests.post(url=self.api_url, json=self.json, headers=self.headers)\n</code></pre>"},{"location":"reference/github_interface/","title":"<code>github_interface()</code>","text":"<p>A class used to interact with the Github API.</p> <p>The class can perform authenticated get, patch and post requests to the GitHub API using the requests library.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>class github_interface():\n    \"\"\"A class used to interact with the Github API.\n\n    The class can perform authenticated get, patch and post requests to the GitHub API using the requests library.\n    \"\"\"\n\n    def __init__(self, token: str) -&gt; None:\n        \"\"\"Creates the header attribute containing the Personal Access token to make auth'd API requests.\n        \"\"\"\n        self.headers = {\"Authorization\": \"token \" + token}\n\n\n    def handle_response(self, response: requests.Response) -&gt; requests.Response | Exception:\n        \"\"\"Checks the passed response for errors and returns the response or an Exception object.\n\n        Args:\n            response (requests.Response): The response to be checked for errors.\n\n        Returns:\n            The response from the API endpoint.\n            If an error occurs, an Exception object is returned to be handled by the importing program.\n        \"\"\"\n\n        try:\n            response.raise_for_status()\n            return response\n        except requests.exceptions.HTTPError as errh:\n            return(errh)\n        except requests.exceptions.ConnectionError as errc:\n            return(errc)\n        except requests.exceptions.Timeout as errt:\n            return(errt)\n        except requests.exceptions.RequestException as err:\n            return(err)\n\n\n    def get(self, url: str, params: dict = {}, add_prefix: bool = True) -&gt; requests.Response | Exception:\n        \"\"\"Performs a get request using the passed url.\n\n            Args:\n                url (str): The url endpoint of the request.\n                params (dict): A Dictionary containing any Query Parameters.\n                add_prefix (bool): A Boolean determining whether to add the \"https://api.github.com\" prefix\n                to the beginning of the passed url.\n\n            Returns:\n                The response from the API endpoint.\n                If an error occurs, an Exception object is returned to be handled by the importing program.\n        \"\"\"\n        if add_prefix:\n            url = \"https://api.github.com\" + url\n        return self.handle_response(requests.get(url=url, headers=self.headers, params=params))\n\n    def patch(self, url: str, params: dict = {}, add_prefix: bool = True) -&gt; requests.Response | Exception:\n        \"\"\"Performs a patch request using the passed url.\n\n            Args:\n                url (str): The url endpoint of the request.\n                params (dict): A Dictionary containing any Query Parameters.\n                add_prefix (bool): A Boolean determining whether to add the \"https://api.github.com\" prefix\n                to the beginning of the passed url.\n\n            Returns:\n                The response from the API endpoint.\n                If an error occurs, an Exception object is returned to be handled by the importing program.\n        \"\"\"\n        if add_prefix:\n            url = \"https://api.github.com\" + url\n        return self.handle_response(requests.patch(url=url, headers=self.headers, json=params))\n\n    def post(self, url: str, params: dict = {}, add_prefix: bool = True) -&gt; requests.Response | Exception:\n        \"\"\"Performs a post request using the passed url.\n\n            Args:\n                url (str): The url endpoint of the request.\n                params (dict): A Dictionary containing any Query Parameters.\n                add_prefix (bool): A Boolean determining whether to add the \"https://api.github.com\" prefix\n                to the beginning of the passed url.\n\n            Returns:\n                The response from the API endpoint.\n                If an error occurs, an Exception object is returned to be handled by the importing program.\n        \"\"\"\n        if add_prefix:\n            url = \"https://api.github.com\" + url\n        return self.handle_response(requests.post(url=url, headers=self.headers, json=params))\n</code></pre>"},{"location":"reference/github_interface/#github_api_toolkit.github_interface.__init__","title":"<code>__init__(token)</code>","text":"<p>Creates the header attribute containing the Personal Access token to make auth'd API requests.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def __init__(self, token: str) -&gt; None:\n    \"\"\"Creates the header attribute containing the Personal Access token to make auth'd API requests.\n    \"\"\"\n    self.headers = {\"Authorization\": \"token \" + token}\n</code></pre>"},{"location":"reference/github_interface/#github_api_toolkit.github_interface.get","title":"<code>get(url, params={}, add_prefix=True)</code>","text":"<p>Performs a get request using the passed url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url endpoint of the request.</p> required <code>params</code> <code>dict</code> <p>A Dictionary containing any Query Parameters.</p> <code>{}</code> <code>add_prefix</code> <code>bool</code> <p>A Boolean determining whether to add the \"https://api.github.com\" prefix</p> <code>True</code> <p>Returns:</p> Type Description <code>Response | Exception</code> <p>The response from the API endpoint.</p> <code>Response | Exception</code> <p>If an error occurs, an Exception object is returned to be handled by the importing program.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def get(self, url: str, params: dict = {}, add_prefix: bool = True) -&gt; requests.Response | Exception:\n    \"\"\"Performs a get request using the passed url.\n\n        Args:\n            url (str): The url endpoint of the request.\n            params (dict): A Dictionary containing any Query Parameters.\n            add_prefix (bool): A Boolean determining whether to add the \"https://api.github.com\" prefix\n            to the beginning of the passed url.\n\n        Returns:\n            The response from the API endpoint.\n            If an error occurs, an Exception object is returned to be handled by the importing program.\n    \"\"\"\n    if add_prefix:\n        url = \"https://api.github.com\" + url\n    return self.handle_response(requests.get(url=url, headers=self.headers, params=params))\n</code></pre>"},{"location":"reference/github_interface/#github_api_toolkit.github_interface.handle_response","title":"<code>handle_response(response)</code>","text":"<p>Checks the passed response for errors and returns the response or an Exception object.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The response to be checked for errors.</p> required <p>Returns:</p> Type Description <code>Response | Exception</code> <p>The response from the API endpoint.</p> <code>Response | Exception</code> <p>If an error occurs, an Exception object is returned to be handled by the importing program.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def handle_response(self, response: requests.Response) -&gt; requests.Response | Exception:\n    \"\"\"Checks the passed response for errors and returns the response or an Exception object.\n\n    Args:\n        response (requests.Response): The response to be checked for errors.\n\n    Returns:\n        The response from the API endpoint.\n        If an error occurs, an Exception object is returned to be handled by the importing program.\n    \"\"\"\n\n    try:\n        response.raise_for_status()\n        return response\n    except requests.exceptions.HTTPError as errh:\n        return(errh)\n    except requests.exceptions.ConnectionError as errc:\n        return(errc)\n    except requests.exceptions.Timeout as errt:\n        return(errt)\n    except requests.exceptions.RequestException as err:\n        return(err)\n</code></pre>"},{"location":"reference/github_interface/#github_api_toolkit.github_interface.patch","title":"<code>patch(url, params={}, add_prefix=True)</code>","text":"<p>Performs a patch request using the passed url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url endpoint of the request.</p> required <code>params</code> <code>dict</code> <p>A Dictionary containing any Query Parameters.</p> <code>{}</code> <code>add_prefix</code> <code>bool</code> <p>A Boolean determining whether to add the \"https://api.github.com\" prefix</p> <code>True</code> <p>Returns:</p> Type Description <code>Response | Exception</code> <p>The response from the API endpoint.</p> <code>Response | Exception</code> <p>If an error occurs, an Exception object is returned to be handled by the importing program.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def patch(self, url: str, params: dict = {}, add_prefix: bool = True) -&gt; requests.Response | Exception:\n    \"\"\"Performs a patch request using the passed url.\n\n        Args:\n            url (str): The url endpoint of the request.\n            params (dict): A Dictionary containing any Query Parameters.\n            add_prefix (bool): A Boolean determining whether to add the \"https://api.github.com\" prefix\n            to the beginning of the passed url.\n\n        Returns:\n            The response from the API endpoint.\n            If an error occurs, an Exception object is returned to be handled by the importing program.\n    \"\"\"\n    if add_prefix:\n        url = \"https://api.github.com\" + url\n    return self.handle_response(requests.patch(url=url, headers=self.headers, json=params))\n</code></pre>"},{"location":"reference/github_interface/#github_api_toolkit.github_interface.post","title":"<code>post(url, params={}, add_prefix=True)</code>","text":"<p>Performs a post request using the passed url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The url endpoint of the request.</p> required <code>params</code> <code>dict</code> <p>A Dictionary containing any Query Parameters.</p> <code>{}</code> <code>add_prefix</code> <code>bool</code> <p>A Boolean determining whether to add the \"https://api.github.com\" prefix</p> <code>True</code> <p>Returns:</p> Type Description <code>Response | Exception</code> <p>The response from the API endpoint.</p> <code>Response | Exception</code> <p>If an error occurs, an Exception object is returned to be handled by the importing program.</p> Source code in <code>github_api_toolkit/__init__.py</code> <pre><code>def post(self, url: str, params: dict = {}, add_prefix: bool = True) -&gt; requests.Response | Exception:\n    \"\"\"Performs a post request using the passed url.\n\n        Args:\n            url (str): The url endpoint of the request.\n            params (dict): A Dictionary containing any Query Parameters.\n            add_prefix (bool): A Boolean determining whether to add the \"https://api.github.com\" prefix\n            to the beginning of the passed url.\n\n        Returns:\n            The response from the API endpoint.\n            If an error occurs, an Exception object is returned to be handled by the importing program.\n    \"\"\"\n    if add_prefix:\n        url = \"https://api.github.com\" + url\n    return self.handle_response(requests.post(url=url, headers=self.headers, json=params))\n</code></pre>"}]}